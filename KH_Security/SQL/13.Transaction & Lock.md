# Transaction & Lock 정리
 
- 트랜잭션은 "반드시 함께 처리되어야 하는 작업 단위"이며,  
Lock과 Undo를 통해 데이터의 일관성과 무결성을 보장한다.

---

## Transaction 특성

| 특성 | 설명 |
|------|------|
| Atomicity (원자성) | 트랜잭션은 전부 수행되거나 전혀 수행되지 않아야 합니다 |
| Consistency (일관성) | 실행 전후 데이터는 항상 제약과 규칙을 만족해야 합니다 |
| Isolation (고립성) | 동시에 실행돼도 중간 결과를 서로 볼 수 없습니다 |
| Durability (영속성) | COMMIT된 결과는 영구적으로 보존됩니다 |

---

## Transaction의 시작 & 종료

### 시작

- 이전 트랜잭션 종료 후
- DML (INSERT, UPDATE, DELETE)
- DDL (CREATE, ALTER, DROP, TRUNCATE)
- DCL (GRANT, REVOKE)

※ 실행 시 시작

### 종료

- COMMIT
- ROLLBACK
- DDL / DCL 실행 완료 시 자동 종료
- 사용자 정상 종료
- 데드락 발생 시 일부 강제 종료

※ 한 세션에서 하나의 트랜잭션만 존재

---

## 트랜잭션과 DML 데이터

### DML 작업 시
- INSERT 등의 DML 작업이 실행되면 **즉시 테이블에 적용된다**
- 변경된 행에는 **독점 잠금(Exclusive lock)** 발생
- 해당 테이블에는 **공유 잠금(Share lock)** 발생
- 트랜잭션이 종료되면 **잠금이 해제된다**

**이해 포인트**
- “즉시 적용”은 **세션 내부에서는 보이는 상태**라는 뜻
- 하지만 “독립성(Isolation)” 때문에 **다른 세션은 COMMIT 전 값을 못 보거나(일반적으로) 대기/일관성 유지가 걸림**
- 그리고 수정 중인 행은 **Exclusive Lock** 때문에 다른 세션의 UPDATE가 **대기**로 빠짐

---

## UNDO SEGMENT

### Undo Segment
- 트랜잭션이 실행 될 때 **이전 이미지**를 저장합니다.
- Rollback을 위해 트랜잭션이 수행되는 동안 **이전 정보**를 저장합니다.

**이해 포인트**
- Undo = “되돌리기 보험”
- COMMIT 전엔 언제든 ROLLBACK 가능해야 하니까, 바꾸기 전 값을 저장합니다

---

## 5) 세그먼트(Segment)

### 세그먼트
- 물리적인 저장 영역을 가진 오브젝트
- 테이블, 인덱스 등 저장 영역에 공간을 할당 받는 오브젝트

**이해 포인트**
- “Undo Segment”는 그냥 개념이 아니라 **실제 디스크/저장 공간(세그먼트)을 가진 Undo 저장소**라는 뜻

---

## UPDATE 1번에 실제로 벌어지는 순서

예시 상황: 기존 값 5 → 7로 변경

### 처리 순서
① undo segment 결정  
② 5를 undo seg에 저장  
③ 7을 테이블에 저장  
④ 행에 독점 잠금(Exclusive Lock)  
⑤ 테이블에 공유 잠금(Share Lock)  
⑥ COMMIT: 7 영구저장 / 잠금 해제  
⑦ ROLLBACK: 5 복원 / 잠금 해제  

### 처리순서 이해

- (값 바꾸기 전)
```text
Row=5
Undo에 5 저장
```

- (값 바꾼 뒤, COMMIT 전)
```text
Row=7  
행 Lock
```

- COMMIT 하면: Row=7 확정 + Lock 해제  
- ROLLBACK 하면: Undo의 5로 복원 + Lock 해제

---

## 잠금으로 인한 대기 현상
- 터미널 1
```sql
  SELECT eno, ename, sal FROM emp WHERE ename = '문시현';
  UPDATE emp SET sal = sal*2 WHERE ename = '문시현';
  SELECT eno, ename, sal FROM emp WHERE ename = '문시현';
```

- (터미널 2)
```sql
  SELECT eno, ename, sal FROM emp WHERE ename = '문시현';
  UPDATE emp SET COMM = 1000 WHERE ename = '문시현'; ← 대기 상태입니다.
```

(터미널 1)

COMMIT;

- **왜 대기?**
```text
터미널1이 ‘문시현’ 행을 수정 중 → 행 Exclusive Lock 상태가 됩니다.

터미널2도 같은 행 수정 시도 → Lock 풀릴 때까지 대기합니다
```

---

## 데드락(Deadlock)

- (터미널 1)
```sql
SELECT * FROM emp WHERE ename IN ('안영희','문시현');
UPDATE emp SET sal = sal*1.2 WHERE ename = '문시현';
UPDATE emp SET COMM = 1000 WHERE ename = '안영희';  ← 대기 상태
```

- (터미널 2)
```sql
SELECT * FROM emp WHERE ename IN ('안영희','문시현');
UPDATE emp SET sal = sal*2 WHERE ename = '안영희';
UPDATE emp SET JOB = '경영' WHERE ename = '문시현';  ← 데드락 발생
```

- 데드락 걸린 이유
```text
터미널1: 문시현 Lock 잡음 → 안영희를 잡으려 함(대기)
터미널2: 안영희 Lock 잡음 → 문시현을 잡으려 함(대기)
서로가 서로의 Lock을 기다림 = 교착 상태
```

- **그래서 DB가 한쪽을 강제 ROLLBACK 해서 교착을 깨버립니다.**
- 그 이후로 데드락이 발생된 원인을 강제로 ROLLBACK 시킨다.
